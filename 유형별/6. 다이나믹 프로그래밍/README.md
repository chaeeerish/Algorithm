## 다이나믹 프로그래밍
> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘
### 다이나믹 프로그래밍
- 중복되는 연산을 줄여서 효율적인 알고리즘을 작성해야 한다.
- 특정 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있다.
- 2가지 방식이 있다.
  - 탑다운
  - 보텀업
- 다음 조건을 만족할 때 사용할 수 있다.
  - 큰 문제를 작은 문제로 나눌 수 있다. (최적 부분 구조)
  - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일한다. (중복 되는 부분 문제 // 동일한 작은 문제를 반복적으로 해결해야 한다.)
- 메모제이션 기법을 사용해서 해결한다.
  - 메모리 공간에 메모해두고 같은 식을 다시 호출하여 메모한 결과를 그대로 가져오는 기법이다.
  - 일명 캐싱이다.
  - 단순히 한 번 구한 정보를 리스트에 저장한다.
- "**이 문제는 이미 해결되었으니까 다시 해결할 필요가 없어**"

- 피보나치 수열 소스 코드 (재귀적)
```python
d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
    
```

- 피보나치 수열 소스 코드 (반복문)
```python
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i-1] + d[i-2]

print(d[n])
```

> 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있다.  
> 이 경우 sys 라이브러리에 포함되어 있는 setrecursionlimit() 함수를 호출하여 재귀 제한을 완화할 수 있다.

### 문제 - 1로 만들기
- 문제 분석
  - 정수 X에 사용할 수 있는 연산은 4가지 이다.
    - X가 5로 나누어 떨어면 5로 나눈다.
    - X가 3으로 나누어 떨어면 3으로 나눈다.
    - X가 2로 나누어 떨어면 2로 나눈다.
    - X에서 1을 뺀다.
  - 연산을 적절히 사용해서 1을 만들자.
- 문제 해설
  - 이 문제는 수를 크게 줄이는 것보다 다른 연산을 적절히 섞는 것이 더 효율적이다.

### 문제 - 개미 전사
- 문제 분석
  - 일직선 상에 존재하는 인접한 식량창고를 공격하면 바로 알아챈다.
  - 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다.
  - 최대한 많은 식량을 얻을 수 있도록 한다.
  - 얻을 수 있는 식량의 최대값
- 문제 해설
  - 점화식
    - Ai = max(Ai-1, Ai-2 + ki)

### 문제 - 바닥 공사
- 문제 분석
  - 가로의 길이가 N
  - 세로의 길이가 2
  - 1*2, 2*1, 2*2의 덮개를 이용해서 채운다.
  - 바닥을 채우는 모든 경우의 수를 구하자.
- 문제 해설
  - 점화식
    - Ai = Ai-1 + Ai-2 * 2

### 문제 - 효율적인 화폐 구성
- 문제 분석
  - N가지 종류의 화폐가 있다.
  - 최소한을 이용해서 가치의 합이 M원이 되도록
- 문제 해설
  - 큰 단위가 작은 단위의 배수가 아니다. 따라서, 그리디 알고리즘으로 풀 수가 없다. 다이나믹 프로그래밍을 이용해야 한다.
  - 점화식
    - Ai = min(Ai, Ai-k + 1)