SELECT BOOK_ID, DATE_FORMAT(PUBLISHED_DATE, '%Y-%m-%d') AS PUBLISHED_DATE
FROM BOOK
WHERE CATEGORY = '인문' AND YEAR(PUBLISHED_DATE) = 2021
ORDER BY PUBLISHED_DATE;


SELECT B.TITLE, B.BOARD_ID, R.REPLY_ID, R.WRITER_ID, R.CONTENTS, DATE_FORMAT(R.CREATED_DATE, '%Y-%m-%d') AS CREATED_DATE
FROM USED_GOODS_BOARD B INNER JOIN USED_GOODS_REPLY R
WHERE B.BOARD_ID = R.BOARD_ID AND YEAR(B.CREATED_DATE) = 2022 AND MONTH(B.CREATED_DATE) = 10
ORDER BY R.CREATED_DATE, B.TITLE;

-- 틀린 이유: 여자를 고려하지 않음
SELECT MEMBER_ID, MEMBER_NAME, GENDER, DATE_FORMAT(DATE_OF_BIRTH, '%Y-%m-%d') AS DATE_OF_BIRTH
FROM MEMBER_PROFILE
WHERE MONTH(DATE_OF_BIRTH) = 3 AND TLNO IS NOT NULL AND GENDER = 'W'
ORDER BY MEMBER_ID;

SELECT DR_NAME, DR_ID, MCDP_CD, DATE_FORMAT(HIRE_YMD, '%Y-%m-%d') AS HIRE_YMD
FROM DOCTOR
WHERE MCDP_CD = 'CS' OR MCDP_CD = 'GS'
ORDER BY HIRE_YMD DESC, DR_NAME
;

-- 틀린 이유: 서브쿼리 뒤에 이름 안붙이고 ; 붙임 ㅋㅋ
SELECT USER_ID, PRODUCT_ID
FROM
(
    SELECT USER_ID, PRODUCT_ID, COUNT(*) AS COUNT_SALE
    FROM ONLINE_SALE
    GROUP BY USER_ID, PRODUCT_ID
) AS SUBQUERY
WHERE COUNT_SALE >= 2
ORDER BY USER_ID, PRODUCT_ID DESC
;

SELECT F.FLAVOR
FROM FIRST_HALF AS F INNER JOIN ICECREAM_INFO AS I
ON F.FLAVOR = I.FLAVOR
WHERE F.TOTAL_ORDER > 3000 AND I.INGREDIENT_TYPE = 'fruit_based'
ORDER BY F.TOTAL_ORDER DESC
;

-- 틀린 이유: 반올림 함수를 몰랐음
SELECT ROUND(AVG(DAILY_FEE), 0) AS AVERAGE_FEE
FROM CAR_RENTAL_COMPANY_CAR
WHERE CAR_TYPE = 'suv'
;

SELECT FACTORY_ID, FACTORY_NAME, ADDRESS
FROM FOOD_FACTORY
WHERE ADDRESS LIKE '강원도%'
ORDER BY FACTORY_ID
;

SELECT PT_NAME, PT_NO, GEND_CD, AGE,
    CASE WHEN TLNO IS NULL THEN 'NONE'
    ELSE TLNO
    END AS TLNO
FROM PATIENT
WHERE AGE <= 12 AND GEND_CD = 'W'
ORDER BY AGE DESC, PT_NAME
;

-- 틀린 이유: UNION 연산은 FROM 안에 넣는거 아니다.
(
    SELECT DATE_FORMAT(SALES_DATE, '%Y-%m-%d') AS SALES_DATE, PRODUCT_ID, USER_ID, SALES_AMOUNT
    FROM ONLINE_SALE
    WHERE YEAR(SALES_DATE) = 2022 AND MONTH(SALES_DATE) = 3
)
UNION
(
    SELECT DATE_FORMAT(SALES_DATE, '%Y-%m-%d') AS SALES_DATE, PRODUCT_ID, NULL AS USER_ID, SALES_AMOUNT
    FROM OFFLINE_SALE
    WHERE YEAR(SALES_DATE) = 2022 AND MONTH(SALES_DATE) = 3
)
ORDER BY SALES_DATE, PRODUCT_ID, USER_ID
;

-- 틀린 이유: 중복을 제거하는 키워드는 DISTINCT이다.
SELECT COUNT(DISTINCT NAME)
FROM ANIMAL_INS
WHERE NAME IS NOT NULL
;

SELECT FISH_INFO.ID, FISH_NAME_INFO.FISH_NAME, TEMP.LENGTH
FROM
(
    SELECT FISH_TYPE, MAX(LENGTH) AS LENGTH
    FROM FISH_INFO
    GROUP BY FISH_TYPE
) AS TEMP
INNER JOIN FISH_INFO
INNER JOIN FISH_NAME_INFO
ON FISH_INFO.LENGTH = TEMP.LENGTH AND FISH_INFO.FISH_TYPE = TEMP.FISH_TYPE AND FISH_INFO.FISH_TYPE = FISH_NAME_INFO.FISH_TYPE
;

-- 틀린 이유: WHERE 절에서는 집계 함수의 결과를 사용할 수 없다.
SELECT TEMP.NAME, TEMP.COUNT
FROM
(
    SELECT NAME, COUNT(*) AS COUNT
    FROM ANIMAL_INS
    GROUP BY NAME
    ORDER BY NAME
) AS TEMP
WHERE TEMP.NAME IS NOT NULL and TEMP.COUNT >= 2
;

-- 틀린 이유: ELSE 뒤에 THEN 필요 없다. 조인 테이블을 CASE에서 사용할 수 없다.
SELECT DISTINCT CAR_ID,
    CASE WHEN CAR_ID IN
        (
            SELECT DISTINCT CAR_ID
            FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
            WHERE START_DATE <= '2022-10-16' AND '2022-10-16' <= END_DATE
        ) THEN '대여중'
    ELSE '대여 가능' END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
ORDER BY CAR_ID DESC
;

-- 틀린 이유: '진료과코드', '5월예약건수'로 정렬이 안된다. 문자 리터럴로 인식되기 때문에!!
SELECT APPOINTMENT.MCDP_CD AS '진료과코드', COUNT(*) AS '5월예약건수'
FROM
(
    SELECT APNT_NO
    FROM APPOINTMENT
    WHERE YEAR(APNT_YMD) = 2022 AND MONTH(APNT_YMD) = 5
) AS TEMP INNER JOIN APPOINTMENT
ON TEMP.APNT_NO = APPOINTMENT.APNT_NO
GROUP BY APPOINTMENT.MCDP_CD
ORDER BY COUNT(*), APPOINTMENT.MCDP_CD
;

SELECT ANIMAL_ID, NAME
FROM ANIMAL_OUTS
WHERE ANIMAL_ID NOT IN
    (
        SELECT ANIMAL_ID
        FROM ANIMAL_INS
    )
ORDER BY ANIMAL_ID, NAME
;

SELECT A.CAR_ID, A.CAR_TYPE, ROUND(A.DAILY_FEE * (100 - A.DISCOUNT_RATE) / 100 * 30, 0) AS FEE
FROM
(
    SELECT CAR_RENTAL_COMPANY_CAR.CAR_ID, CAR_RENTAL_COMPANY_CAR.CAR_TYPE, CAR_RENTAL_COMPANY_CAR.DAILY_FEE, CAR_RENTAL_COMPANY_DISCOUNT_PLAN.DISCOUNT_RATE
    FROM CAR_RENTAL_COMPANY_CAR INNER JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN
    ON CAR_RENTAL_COMPANY_CAR.CAR_TYPE = CAR_RENTAL_COMPANY_DISCOUNT_PLAN.CAR_TYPE
    AND (CAR_RENTAL_COMPANY_CAR.CAR_TYPE = '세단' OR CAR_RENTAL_COMPANY_CAR.CAR_TYPE = 'SUV') AND CAR_RENTAL_COMPANY_DISCOUNT_PLAN.DURATION_TYPE LIKE '30%'
) AS A
WHERE A.CAR_ID NOT IN (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE END_DATE >= '2022-11-01' AND START_DATE <= '2022-12-01'
)
HAVING FEE >= 500000 AND FEE < 2000000
ORDER BY FEE DESC, CAR_TYPE, CAR_ID DESC
;

-- 틀린 이유: DATEDIFF(2022-09-30, 2022-09-01)는 29일을 반환한다.
SELECT HISTORY_ID, CAR_ID, DATE_FORMAT(START_DATE, '%Y-%m-%d') AS START_DATE, DATE_FORMAT(END_DATE, '%Y-%m-%d') AS END_DATE,
    CASE WHEN DATEDIFF(END_DATE, START_DATE) >= 29 THEN '장기 대여'
    ELSE '단기 대여' END AS RENT_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE YEAR(START_DATE) = 2022 AND MONTH(START_DATE) = 9
ORDER BY HISTORY_ID DESC
;

-- 틀린 이유: 숫자를 문자열로 변환할 때는 CONCAT을 사용한다. QUARTER 함수로 분기를 구할 수 있다.
SELECT CONCAT(QUARTER(DIFFERENTIATION_DATE), 'Q') AS QUARTER, COUNT(ID) AS ECOLI_COUNT
FROM ECOLI_DATA
GROUP BY QUARTER
ORDER BY QUARTER
;

-- 틀린 이유: ROUND(~, 2)은 소수 셋째자리에서 반올림하여 둘째자리부터 보이는 함수이다.
SELECT YEAR(YM) AS YEAR, ROUND(AVG(PM_VAL1), 2) AS 'PM10', ROUND(AVG(PM_VAL2), 2) AS 'PM2.5'
FROM AIR_POLLUTION
WHERE LOCATION1 = '경기도' AND LOCATION2 = '수원'
GROUP BY YEAR
ORDER BY YEAR
;

-- 틀린 이유: 8 <= MONTH(START_DATE) <= 10은 올바른 문법이 아니다. MONTH(START_DATE) BETWEEN 8 AND 10를 사용해야 한다.
SELECT MONTH(START_DATE) AS MONTH, CAR_ID, COUNT(*) AS RECORDS
FROM (
    SELECT *
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE YEAR(START_DATE) = 2022 AND MONTH(START_DATE) BETWEEN 8 AND 10
) AS A
WHERE CAR_ID IN (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE YEAR(START_DATE) = 2022 AND MONTH(START_DATE) BETWEEN 8 AND 10
    GROUP BY CAR_ID
    HAVING COUNT(*) >= 5
)
GROUP BY MONTH(START_DATE), CAR_ID
HAVING RECORDS > 0
ORDER BY MONTH(START_DATE), CAR_ID DESC
;